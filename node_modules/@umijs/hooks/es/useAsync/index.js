function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _await(value, then, direct) {
  if (direct) {
    return then ? then(value) : value;
  }

  if (!value || !value.then) {
    value = Promise.resolve(value);
  }

  return then ? value.then(then) : value;
}

function _async(f) {
  return function () {
    for (var args = [], i = 0; i < arguments.length; i++) {
      args[i] = arguments[i];
    }

    try {
      return Promise.resolve(f.apply(this, args));
    } catch (e) {
      return Promise.reject(e);
    }
  };
}

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

import { useCallback, useState, useRef, useEffect } from 'react';

var Timer = function Timer(cb, delay) {
  var _this = this;

  _classCallCheck(this, Timer);

  this.remaining = 0;
  this.delay = 0;
  this.cb = null;
  this.start = 0;
  this.timerId = 0;

  this.stop = function () {
    clearTimeout(_this.timerId);
    _this.timerId = 0;
    _this.remaining = _this.delay;
  };

  this.pause = function () {
    clearTimeout(_this.timerId);
    _this.remaining -= Date.now() - _this.start;
  };

  this.resume = function () {
    _this.start = Date.now();
    clearTimeout(_this.timerId);
    _this.timerId = setTimeout(_async(function () {
      if (_this.cb) {
        _this.cb();
      }

      return _await();
    }), _this.remaining);
  };

  this.remaining = delay;
  this.delay = delay;
  this.start = Date.now();
  this.cb = cb;
};

var noop = function noop() {};

var promiseReturn = function promiseReturn() {
  return _await(null);
};

function useAsync(fn, deps, options) {
  var _deps = Array.isArray(deps) ? deps : [];

  var _options = _typeof(deps) === 'object' && !Array.isArray(deps) ? deps : options || {};

  var params = useRef([]);
  var _options$autoCancel = _options.autoCancel,
      autoCancel = _options$autoCancel === void 0 ? true : _options$autoCancel;
  var timer = useRef(undefined);
  var omitNextResume = useRef(false);
  var count = useRef(0);
  var fnRef = useRef(fn);
  fnRef.current = fn;
  var onSuccessRef = useRef(_options.onSuccess);
  onSuccessRef.current = _options.onSuccess;
  var onErrorRef = useRef(_options.onError);
  onErrorRef.current = _options.onError; // initial loading state is related to manual option

  var _useState = useState({
    data: undefined,
    error: undefined,
    loading: !_options.manual
  }),
      _useState2 = _slicedToArray(_useState, 2),
      state = _useState2[0],
      set = _useState2[1];

  var run = useCallback(function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    // 确保不会返回被取消的结果
    var runCount = count.current;
    /* 当前参数保存一下 */

    params.current = args;
    set(function (s) {
      return _objectSpread({}, s, {
        loading: true
      });
    });
    return fnRef.current.apply(fnRef, args).then(function (data) {
      if (runCount === count.current) {
        set(function (s) {
          return _objectSpread({}, s, {
            data: data,
            loading: false
          });
        });

        if (onSuccessRef.current) {
          onSuccessRef.current(data, args || []);
        }
      }

      return data;
    }).catch(function (error) {
      if (runCount === count.current) {
        set(function (s) {
          return _objectSpread({}, s, {
            error: error,
            loading: false
          });
        });

        if (onErrorRef.current) {
          onErrorRef.current(error, args || []);
        }
      }

      throw error;
    });
  }, []);
  /* 软取消，由于竞态，需要取消上一次的请求 */

  var softCancel = useCallback(function () {
    if (autoCancel) {
      count.current += 1;
      set(function (s) {
        return _objectSpread({}, s, {
          loading: false
        });
      });
    }
  }, [autoCancel]);
  /* 强制取消，组件卸载，或者用户手工取消 */

  var forceCancel = useCallback(function () {
    count.current += 1;
    set(function (s) {
      return _objectSpread({}, s, {
        loading: false
      });
    });
  }, []);
  var stop = useCallback(function () {
    if (timer.current) {
      timer.current.stop();
      omitNextResume.current = true;
    }

    forceCancel();
  }, [forceCancel]);
  var resume = useCallback(function () {
    if (timer.current) {
      omitNextResume.current = false;
      timer.current.resume();
    }
  }, []);
  var pause = useCallback(function () {
    if (timer.current) {
      timer.current.pause();
      omitNextResume.current = true;
    }

    forceCancel();
  }, [forceCancel]);
  var start = useCallback(_async(function () {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    // 有定时器的延时逻辑
    if (_options.pollingInterval) {
      if (timer.current) {
        stop();
      }

      omitNextResume.current = false;
      timer.current = new Timer(function () {
        return start.apply(void 0, args);
      }, _options.pollingInterval);
      var ret = run.apply(void 0, args);
      ret.finally(function () {
        if (timer.current && !omitNextResume.current) {
          timer.current.resume();
        }
      });
      return ret;
    } // 如果上一次异步操作还在 loading，则会尝试取消掉上一次的异步操作。


    softCancel();
    return run.apply(void 0, args);
  }), [run, softCancel, stop, _options.pollingInterval]);
  useEffect(function () {
    if (!_options.manual) {
      // deps 变化时，重新执行
      start();
    }
    /* 如果 desp 变化，强制取消 */


    return function () {
      if (timer.current) {
        timer.current.stop();
      }

      forceCancel();
    };
  }, [].concat(_toConsumableArray(_deps), [forceCancel, start]));
  return {
    loading: state.loading,
    params: params.current,
    error: state.error,
    data: state.data,
    cancel: forceCancel,
    run: start,
    timer: {
      stop: stop,
      resume: resume,
      pause: pause
    }
  };
}

export default useAsync;