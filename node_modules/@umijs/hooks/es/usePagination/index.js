function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

import { useState, useEffect, useCallback, useMemo } from 'react';
import useAsync from '../useAsync';
import useUpdateEffect from '../useUpdateEffect';

function usePagination(fn, deps, options) {
  var _deps = Array.isArray(deps) ? deps : [];

  var _options = _typeof(deps) === 'object' && !Array.isArray(deps) ? deps : options || {};

  var _options$defaultPageS = _options.defaultPageSize,
      defaultPageSize = _options$defaultPageS === void 0 ? 10 : _options$defaultPageS,
      formatResult = _options.formatResult;

  var _useState = useState([]),
      _useState2 = _slicedToArray(_useState, 2),
      data = _useState2[0],
      setData = _useState2[1];

  var _useState3 = useState(0),
      _useState4 = _slicedToArray(_useState3, 2),
      total = _useState4[0],
      setTotal = _useState4[1];

  var _useState5 = useState(1),
      _useState6 = _slicedToArray(_useState5, 2),
      current = _useState6[0],
      setCurrent = _useState6[1];

  var _useState7 = useState(defaultPageSize),
      _useState8 = _slicedToArray(_useState7, 2),
      pageSize = _useState8[0],
      setPageSize = _useState8[1];

  var _useState9 = useState(0),
      _useState10 = _slicedToArray(_useState9, 2),
      count = _useState10[0],
      setCount = _useState10[1]; // let shamFn!: (params: FnParams) => Promise<FormattedResult<Item>>;
  // if (Array.isArray(fn)) {
  //   shamFn = (params) => {
  //     return new Promise((resolve) => {
  //       resolve({
  //         data: fn.slice((params.current - 1) * params.pageSize, params.current * params.pageSize),
  //         total: fn.length
  //       });
  //     });
  //   }
  // }


  var _useAsync = useAsync(fn, _deps, {
    manual: true
  }),
      run = _useAsync.run,
      loading = _useAsync.loading;

  useEffect(function () {
    run({
      current: current,
      pageSize: pageSize
    }).then(function (res) {
      if (!res) {
        return;
      }

      var formattedResult = formatResult ? formatResult(res) : res;

      if (formattedResult) {
        if (typeof formattedResult.total === 'number') setTotal(formattedResult.total);
        if (formattedResult.data) setData(formattedResult.data);
        if (typeof formattedResult.current === 'number') setCurrent(formattedResult.current);
        if (typeof formattedResult.pageSize === 'number') setPageSize(formattedResult.pageSize);
      }
    });
  }, [current, pageSize, count]);
  useUpdateEffect(function () {
    setCurrent(1);
    setCount(function (c) {
      return c + 1;
    });
  }, _deps);
  var totalPage = useMemo(function () {
    return Math.ceil(total / pageSize);
  }, [pageSize, total]);
  var onChange = useCallback(function (c, p) {
    var toCurrent = c <= 0 ? 1 : c;
    var toPageSize = p <= 0 ? 1 : p;
    var tempTotalPage = Math.ceil(total / toPageSize);

    if (toCurrent > tempTotalPage) {
      toCurrent = tempTotalPage;
    }

    setCurrent(toCurrent);
    setPageSize(toPageSize);
  }, [total]);
  var changeCurrent = useCallback(function (c) {
    onChange(c, pageSize);
  }, [onChange, pageSize]);
  var changePageSize = useCallback(function (p) {
    onChange(current, p);
  }, [onChange, current]);
  var refresh = useCallback(function () {
    setCount(function (c) {
      return c + 1;
    });
  }, []);
  return {
    data: data,
    loading: loading,
    pagination: {
      current: current,
      pageSize: pageSize,
      total: total,
      totalPage: totalPage,
      onChange: onChange,
      changeCurrent: changeCurrent,
      changePageSize: changePageSize
    },
    refresh: refresh
  };
}

export default usePagination;