"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = require("react");

var _useAsync2 = _interopRequireDefault(require("./useAsync"));

var _useUpdateEffect = _interopRequireDefault(require("./utils/useUpdateEffect"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function usePaginated(service, options) {
  var paginated = options.paginated,
      _options$defaultPageS = options.defaultPageSize,
      defaultPageSize = _options$defaultPageS === void 0 ? 10 : _options$defaultPageS,
      _options$refreshDeps = options.refreshDeps,
      refreshDeps = _options$refreshDeps === void 0 ? [] : _options$refreshDeps,
      fetchKey = options.fetchKey,
      restOptions = _objectWithoutProperties(options, ["paginated", "defaultPageSize", "refreshDeps", "fetchKey"]);

  (0, _react.useEffect)(function () {
    if (fetchKey) {
      console.error('useRequest pagination\'s fetchKey will not work!');
    }
  }, []);

  var _useAsync = (0, _useAsync2.default)(service, _objectSpread({
    defaultParams: [{
      current: 1,
      pageSize: defaultPageSize
    }]
  }, restOptions)),
      data = _useAsync.data,
      params = _useAsync.params,
      run = _useAsync.run,
      loading = _useAsync.loading,
      rest = _objectWithoutProperties(_useAsync, ["data", "params", "run", "loading"]);

  var _ref = params && params[0] ? params[0] : {},
      _ref$current = _ref.current,
      current = _ref$current === void 0 ? 1 : _ref$current,
      _ref$pageSize = _ref.pageSize,
      pageSize = _ref$pageSize === void 0 ? defaultPageSize : _ref$pageSize,
      _ref$sorter = _ref.sorter,
      sorter = _ref$sorter === void 0 ? {} : _ref$sorter,
      _ref$filters = _ref.filters,
      filters = _ref$filters === void 0 ? {} : _ref$filters; // 只改变 pagination，其他参数原样传递


  var runChangePaination = (0, _react.useCallback)(function (paginationParams) {
    var _params = _toArray(params),
        oldPaginationParams = _params[0],
        restParams = _params.slice(1);

    run.apply(void 0, [_objectSpread({}, oldPaginationParams, {}, paginationParams)].concat(_toConsumableArray(restParams)));
  }, [run, params]);
  var total = (data === null || data === void 0 ? void 0 : data.total) || 0;
  var totalPage = (0, _react.useMemo)(function () {
    return Math.ceil(total / pageSize);
  }, [pageSize, total]);
  var onChange = (0, _react.useCallback)(function (c, p) {
    var toCurrent = c <= 0 ? 1 : c;
    var toPageSize = p <= 0 ? 1 : p;
    var tempTotalPage = Math.ceil(total / toPageSize);

    if (toCurrent > tempTotalPage) {
      toCurrent = tempTotalPage;
    }

    runChangePaination({
      current: c,
      pageSize: p
    });
  }, [total, runChangePaination]);
  var changeCurrent = (0, _react.useCallback)(function (c) {
    onChange(c, pageSize);
  }, [onChange, pageSize]);
  var changePageSize = (0, _react.useCallback)(function (p) {
    onChange(current, p);
  }, [onChange, current]);
  var changeCurrentRef = (0, _react.useRef)(changeCurrent);
  changeCurrentRef.current = changeCurrent;
  /* 分页场景下，如果 refreshDeps 变化，重置分页 */

  (0, _useUpdateEffect.default)(function () {
    /* 只有自动执行的场景， refreshDeps 才有效 */
    if (!options.manual) {
      changeCurrentRef.current(1);
    }
  }, _toConsumableArray(refreshDeps)); // 表格翻页 排序 筛选等

  var changeTable = (0, _react.useCallback)(function (p, f, s) {
    runChangePaination({
      current: p.current,
      pageSize: p.pageSize || defaultPageSize,
      filters: f,
      sorter: s
    });
  }, [filters, sorter, runChangePaination]);
  return _objectSpread({
    loading: loading,
    data: data,
    params: params,
    run: run,
    pagination: {
      current: current,
      pageSize: pageSize,
      total: total,
      totalPage: totalPage,
      onChange: onChange,
      changeCurrent: changeCurrent,
      changePageSize: changePageSize
    },
    tableProps: {
      dataSource: (data === null || data === void 0 ? void 0 : data.list) || [],
      loading: loading,
      onChange: changeTable,
      pagination: {
        current: current,
        pageSize: pageSize,
        total: total
      }
    },
    sorter: sorter,
    filters: filters
  }, rest);
}

var _default = usePaginated;
exports.default = _default;